# 数据库系统的概念

数据库系统由数据库、数据库管理系统和硬件等组成，数据库系统是在文件系统的基础上发展起来的。数据库系统由于能够减少数据冗余，提高数据独立性，并集中检查数据完整性，才获得了广泛的应用。数据库系统提供给用户的接口是数据库语言，具有数据定义、数据操作和数据检查功能，可独立使用，也可嵌入宿主语言使用。SQL语言已被国际化标准化组织采纳为关系型数据库的标准语言。



# 三级模式与二级映射

数据库系统由外模式、模式和内模式三级构成

1. **外模式，对应于用户级数据库。**外模式（子模式、用户模式）用以描述用户看到或使用的那部分数据的逻辑结构，用户根据外模式用数据操作语句或应用程序去操作数据库中的数据。外模式主要描述组成用户视图的各个记录的组成、相互关系、数据项的特征、数据的安全性和完整性约束条件
   外模式是数据库用户（包括程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。
   **一个数据库可以有多个外模式。一个应用程序只能使用一个外模式**
2. **概念模式，对应于概念级数据库。**概念模式（模式、逻辑模式）用以描述整个数据库中数据库的逻辑结构，描述现实世界中的实体及其性质与联系，定义记录、数据项、数据的完整性约束条件及记录之间的联系，是数据项值的框架
   数据库系统概念模式通常还包含有访问控制，保密定义，完整性检查等方面的内容，以及概念/物理之间的映射
   概念模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。**一个数据库只有一个概念模式**
3. **内模式，对应于物理级数据库。**内模式是整个数据库的最低层表示，不同于物理层，它假设外存是一个无限的线性地址空间。内模式定义的是存储记录的类型、存储域的表示以及存储记录的物理顺序，指引元、索引和存储路径等数据的存储组织
   内模式是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。**一个数据库只有一个内模式**



数据库系统两级独立性是指**物理独立性**和**逻辑独立性**。三个抽象级间通过**两级映射（外模式/模式映射，模式/内模式映射）**进行相互转换，使得数据库的三级形成一个统一的整体

1. 物理独立性。物理独立性是指用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的。当数据的物理存储改变时，应用程序不需要改变。
   物理独立性存在于概念模式和内模式之间的映射转换，说明物理组织发生变化时应用程序的独立程度
2. 逻辑独立性。逻辑独立性是指用户的应用程序与数据库中的逻辑结构是相互独立的。当数据的逻辑结构改变时，应用程序不需要改变
   逻辑独立性存在于外模式和概念模式之间的映射转换，说明概念模式发生变化时应用程序的独立程度。逻辑独立性比物理独立性更难实现



# ER数据模型

ER数据模型所采用的三个主要概念是：实体集、联系集和属性。这三个是构成ER模型的基本成分

+ 实体集（矩形框表示），指具有相同类型及相同性质（属性）的实体集合
+ 联系集（菱形表示），同类联系的集合
+ 属性（椭圆表示），对于键属性，在属性名下画一条横线表示

两个实体型之间的联系可以分成下述三类

+ 一对一联系（1：1）
+ 一对多联系（1：n）
+ 多对多联系（m：n）



# 笛卡儿积、连接、投影、选择

**笛卡儿积运算**，假设关系R和关系S的元素个数与属性个数分别为m和n。R×S表示R和S的笛卡儿积，R×S={（m+n）个属性的一个元组集合，每个元组的前m个属性值来自R的一个元组，后n个属性值来自S的一个元组的所有组合}

**连接**是从两个关系的笛卡儿积结果中选取属性间满足一定条件的元组

**投影**是从关系中挑选若干属性组成新的关系，它是对关系进行**列操作**的方法

**选择**是从关系中找到满足条件的所有元组的操作，即不改变关系表中的属性个数但能减少元组个数的操作，它是对关系进行**行操作**的方法



# 自然连接

自然连接，是通过两个关系中相同属性的相同值来进行连接的一种关系运算



# 分布式数据系统

分布式数据系统是传统集中式数据库系统的发展，因此它具有集中式数据库系统的特点。同时，由于它的分布性而又使这些特点具有新的含义。传统的数据库系统针对文件系统的弱点，采用了集中控制以实现数据共享。对于分布式数据库系统来说，由于数据的分散性，分布式数据库系统具有分散与集中统一的特性。分布式主要有以下几个特点：

1. 数据的集中控制性，分布式数据库是由传统的数据库发展而来，因此也具有集中控制的特性
2. 数据独立性，独立性指的是数据的组成对应用程序来说是透明的。应用程序只需要考虑数据的逻辑结构，而不用考虑数据的物理存放，因而数据在物理组织上的改变不会影响应用程序
3. 数据冗余可控性，分布式数据库中的数据一般存储在经常使用的场地上，但应用对两个或两个以上场地的同一数据有存取要求也是时常发生的，而且当传输代价高于存储代价时，可以将同一数据存储在两个（甚至更多）场地上，以节省传输的开销。由于这种冗余是在系统控制下的，所有给系统造成的不利影响是可控制的
4. 场地自治性，局部用户所使用的数据可以不参与到全局数据库中去，这种局部应用独立于全局应用的特性就是局部数据库的自治性。存取的有效性分布式数据库系统的全局查询可以分解成等效的子查询，即全局查询的执行计划可分解成多个子查询执行计划，而子查询计划又是在各场地上分布执行的



# 数据仓库的特性

+ 面向主题的特性是指将关于主题的数据组织起来分析数据及数据之间的关系。
+ 集成是将业务系统中关于主题的数据集中起来，对数据进行一系列预处理。随时间变化的特征体是不进行分析数据更新操作，但数据仓库随时间变化会不断增加，删除，修改数据



# X封锁和S封锁

处理并发控制的主要方法是采用封锁技术。常见的主要有两种封锁：X封锁和S封锁。

1. 排他型封锁（简称X封锁）：如果事务T对数据A（可以是数据项、记录、数据集以至整个数据库）实现了X封锁，那么只允许事务T读取和修改数据A，其他事务要等事务T解除X封锁以后，才能对数据A实现任何类型的封锁。可见X封锁只允许一个事务独锁某个数据，具有排他性
2. 共享型封锁（简称S封锁）：X封锁只允许一个事务独锁和使用数据，要求太严。需要适当从宽，例如可以允许使用数据，但不允许修改，这就产生了S封锁概念。
   S封锁的含义是，如果事务T对数据A实现了S封锁，那么允许事务T读取数据A，但不能修改数据A，在所有S封锁解除之前决不允许任何事务对数据A实现X封锁



# 事务的特性（ACID特性）

数据库管理系统运行的基本工作单位是事务，事务是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。事务具有以下特性（ACID特性）

1. 原子性：数据库的逻辑工作单位
   事务的原子性保证事务包含的一组更新操作是原子不可分的，也就是说这些操作是一个整体，对数据库而言全做或全不做，不能部分完成。这一性质即使在系统崩溃之后仍能得到保证，在系统崩溃之后将进行数据库恢复，用来恢复和撤销系统崩溃处于活动状态的事务对数据库的影响，从而保证事务的原子性。系统对磁盘上的任何实际数据的修改之前都会将修改操作信息本身的信息记录到磁盘上。当发生崩溃时，系统能根据这些操作记录当时该事务处于何种状态，以此确定是撤销该事务所做的所有修改操作还是将修改的操作重新执行
2. 一致性：使数据库从一个一致性状态变到另一个一致性状态
   一致性要求事务执行完成后，将数据库从一个一致状态转变到另一个一致状态。它是一种以一致性规则为基础的逻辑属性。例如，在转账的操作中，各账户金额必须平衡，这一条规则对于程序员而言是一个强制的规定，由此可见，一致性与原子性是密切相关的。事务的一致性属性要求事务在并发执行的情况下事务的一致性仍然满足。它在逻辑上不是独立的，由事务的隔离性来表示。
3. 隔离性：不能被其他事务干扰
   隔离性意味着一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。它要求即使有多个事务并发执行，看上去每个成功事务按串行调度执行一样。这一性质的另一种称法为可串行性，也就是说系统允许的任何交错操作调度等价于一个串行调度。串行调度的意思是每次调度一个事务，在一个事务的所有操作没有结束之前，另外的事务操作不能开始。由于性能原因，需要进行交错操作的调度，但也希望这些交错操作的调度的效果和某一个串行调度是一致的。DM实现该机制是通过对事务的数据访问对象加适当的锁，从而排斥其他的事务对同一数据库对象的并发操作
4. 持续性（永久性）：一旦提交，改变就是永久性的
   系统提供的持久性保证要求一旦事务提交，那么对数据库所做的修改将是持久的，无论发生何种机器和系统故障都不应该对其有任何影响。例如，自动柜员机（ATM）在向客户支付一笔钱时，就不用担心丢失客户的取款记录。事务的持久性保证事务对数据库的影响是持久的，即使系统崩溃。正如在讲原子性时所提到的那样，系统通过做记录来提供这一保证



# 丢失更新，不能重复读，读“脏”数据

丢失更新：丢失更新是指两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。

不能重复读：不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果

读“脏”数据：读“脏”数据是指事务T1修改某一数据并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，这时T1修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，即T2读到了“脏”数据。



# 数据约束

数据约束是用来确保数据的准确性和一致性的。常见的4种数据约束如下：

1. 实体完整性约束：规定表的每一行在表中是唯一的实体
2. 域完整性约束：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围，精度等规定
3. 参照完整性约束：是指两个表的主关键字和外关键字的数据应一致，保证了表之间数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散
4. 用户定义的完整性约束：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定的关系数据库的约束条件，反映某一具体应用必须满足的语义要求

在上述四种数据约束中，不属于关系模型定义的三种数据约束的是域完整性约束



# 故障的种类

+ 事务故障是非预期的，是不能由应用程序处理的故障如运算溢出，并行事务发生死锁而被选中撤销该事务等。事务故障意味着事务没有到达预期的终点
+ 系统故障是指造成系统停止运转的任何事件，使得系统重新启动，如中央处理器故障，操作系统故障，突然停电等
+ 介质故障又称硬故障，是指外存故障，如磁盘的磁头碰撞，瞬时的强磁场干扰等



# 函数依赖

124页的例1，例2

## 什么是函数依赖

例如，对学生关系模式Student(Sno,Sname,Sdept,Sage)有以下函数依赖关系

Sno->Sname, Sno->Sdept, Sno->Sage

对学生选课关系模式，SC(Sno, Cno, Grade)有以下函数依赖关系

(Sno, Cno)->Grade

这些就是函数依赖，当然只有例子，具体公式看课本



## 主属性和非主属性

包含在候选码中的属性为主属性，不包含在任何候选码中的属性称为非主属性



## 术语符号

例1 假设有关系模式SC(Sno, Sname, Cno, Credit, Grade)，其中各属性分别为：学号，姓名，课程号，学分，成绩，主码为(Sno, Cno)，则函数依赖关系如下

| Sno->Sname          | 姓名函数依赖于学号             |
| ------------------- | ------------------------------ |
| (Sno, Cno)->P Sname | 姓名部分函数依赖于学号和课程号 |
| (Sno, Cno)->f Grade | 成绩完全函数依赖于学号和课程号 |



例2 假设有关系模式S(Sno, Sname, Dept, Dept_master)，其中各属性分别为：学号，姓名，所在系和系主任（假设一个系只有一个主任），主码为Sno，则函数依赖关系如下

| Sno->f Sname          | 姓名完全函数依赖于学号   |
| --------------------- | ------------------------ |
| Sno->f Dept           | 所在系完全函数依赖于学号 |
| Dept->f Dept_master   | 系主任完全函数依赖于系   |
| Sno->传递 Dept_master | 系主任传递函数依赖于学号 |



## 属性集闭包

见课本例题P125

求属性集闭包的用途：如果属性集X的闭包X+包含了R中的全部属性，则X为R的一个候选码



## 候选码的求解方法

对于给定的关系模式R(A1,A2,...An)和函数依赖集F，现将R的属性分为如下4类

1. L类，仅出现在函数依赖左部的属性
2. R类，仅出现在函数依赖右部的属性
3. N类，在函数依赖的左部和右部均不出现的属性
4. LR类，在函数依赖的左部和右部均出现的属性

对R中的属性X，可有以下结论

1. 若X是L类属性，则X一定包含在关系模式R的任何一个候选码中；若X+包含了R的全部属性，则X为关系模式R的唯一候选码
2. 若X是R类属性，则X不包含在关系模式R的任何一个候选码中
3. 若X是N类属性，则X一定包含在关系模式R的任何一个候选码中
4. 若X是LR类属性，则X可能包含在关系模式R的某个候选码中



## 极小函数依赖集

对关系模式R(U,F)，如果函数依赖集F满足下列条件，则称F为R的一个极小函数依赖集，记为Fmin

1. F中每个函数依赖的右部仅含有一个属性
2. F中每个函数依赖的左部不存在多余的属性
3. F中不存在多余的函数依赖

计算极小函数依赖集的算法如下

1. 使F中每个函数依赖的右部都只有一个属性
2. 去掉各函数依赖左部多余的属性
3. 去掉多余的函数依赖



## 关系规范化

### 第一范式

定义 如果关系模式R中所有的属性都是基本属性，即每个属性都是不可再分的，则称R属于第一范式，简称1NF



### 第二范式

定义 如果关系模式R属于1NF，并且R中的每个非主属性都完全函数依赖于主码，则称R属于第二范式，简称2NF

从定义可以看出，若关系模式R属于1NF，且R的主码只由一个属性组成，那么一定有R属于2NF。但如果主码是由多个属性共同构成的复合主码，并且存在非主属性对主码的部分函数依赖，则R就不是2NF

变成第二范式的步骤：

1. 用组成主码的属性集合的每一个子集作为主码构成一个关系模式
2. 将依赖于这些主码的属性放置到相应的关系模式中
3. 最后去掉只由主码的子集构成的关系模式



### 第三范式

定义 如果关系模式R属于2NF，且每个非主属性都不传递函数依赖于主码，则称R属于第三范式，简称3NF

从定义可以看出，如果存在非主属性对主码的传递依赖，则相应的关系模式就不是3NF

变成第三范式的步骤：

1. 对于不是候选码的每个决定因子，从关系模式中删去依赖于它的所有属性
2. 新建一个关系模式，新关系模式中包含在原关系模式中所有依赖于该决定因子的属性
3. 将决定因子作为新关系模式的主码



第一范式，所有属性是基本属性，第二范式，不能有部分函数依赖，第三范式，不能有传递函数依赖



### BC范式

当且仅当关系中的每个函数依赖的决定因子都是候选码时，该范式即为BCNF



## 无损连接性和保持函数依赖

分解要具有无损连接性，即分解后的关系模式经过连接操作后能够还原出分解前的关系模式

分解要保持函数依赖，即分解后各关系模式中存在的函数依赖，不能比分解前关系模式的函数依赖多，也不能比分解前关系模式的函数依赖少





