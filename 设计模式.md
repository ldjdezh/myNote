# 设计模式

## 面向对象设计原则

+ 对接口编程而不是对实现编程
+ 优先使用对象组合而不是继承



## 设计模式的类型

总共有23中设计模式，分为三大类：创建型模式(Creational Patterns)、结构型模式(Structural Patterns)，行为型模式(Behavioral Patterns)。同时，也讨论另一类设计模式：J2EE设计模式

| 序号 | 模式 & 描述                                                  | 包括                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | 创建型模式<br />这些设计模式提供了一种在创建对象在同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活 | 工厂模式<br />抽象工厂模式<br />单例模式<br />建造者模式<br />原型模式 |
| 2    | 结构型模式<br />这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式 | 适配器模式<br />桥接模式<br />过滤器模式<br />组合模式<br />装饰器模式<br />外观模式<br />享元模式<br />代理模式 |
| 3    | 行为型模式<br />这些设计模式特别关注对象之间的通信           | 责任链模式<br />命令模式<br />解释器模式<br />迭代器模式<br />中介者模式<br />备忘录模式<br />观察者模式<br />状态模式<br />空对象模式<br />策略模式<br />模板模式<br />访问者模式 |
| 4    | J2EE模式<br />这些设计模式特别关注表示层。这些模式是由Sun Java Center鉴定在 | MVC模式<br />业务代表模式<br />组合实体模式<br />数据访问对象模式<br />前端控制器模式<br />拦截过滤器模式<br />服务定位器模式<br />传输对象模式 |

创建型模式 -> 对象怎么来

结构型模式 -> 对象和谁有关

行为型模式 -> 对象与对象在干嘛

J2EE模式 -> 对象合起来要干嘛



## 设计模式在六大原则

1. 开闭原则：**对扩展开放，对修改关闭。**实现热插拔，提高扩展性
2. 里氏代换原则：实现抽象的规范，实现子父类互相替换
3. 依赖倒转原则：针对接口编程，实现开闭原则的基础
4. 接口隔离原则：降低耦合度，接口单独设计，互相隔离
5. 迪米特法则：又称不知道原则：功能模块尽力独立
6. 合成复用原则：尽量使用聚合，组合，而不是继承



## 工厂模式

创建对象时不会对客户端暴露创建逻辑，并且通过使用一个共同的接口来指向新创建的对象

### 示例代码

创建接口`Shape.java`

```java
package factoryPattern;

public interface Shape {
	void draw();
}

```



创建实现接口的实体类

`Rectangle.java`

```java
package factoryPattern;

public class Rectangle implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Rectangle::draw() method");
	}

}

```



`Square.java`

```java
package factoryPattern;

public class Square implements Shape{

	@Override
	public void draw() {
		System.out.println("Inside Square::draw() method");
	}
	
}

```



`Circle.java`

```java
package factoryPattern;

public class Circle implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Circle::draw() method");
	}

}

```



创建一个工厂，生成基于给定信息的实体类的对象

`ShapeFactory.java`

```java
package factoryPattern;

public class ShapeFactory {
	public Shape getShape(String shapeType) {
		if (shapeType == null) {
			return null;
		}

		if (shapeType.equalsIgnoreCase("CIRCLE")) {
			return new Circle();
		} else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
			return new Rectangle();
		} else if (shapeType.equalsIgnoreCase("SQUARE")) {
			return new Square();
		}

		return null;
	}
}

```



使用该工厂，通过传递类型信息来获取实体类的对象

`FactoryPatternDemo.java`

```java
package factoryPattern;

public class FactoryPatternDemo {
	public static void main(String[] args) {
		ShapeFactory sf = new ShapeFactory();

		Shape s1 = sf.getShape("CIRCLE");
		s1.draw();

		Shape s2 = sf.getShape("RECTANGLE");
		s2.draw();

		Shape s3 = sf.getShape("SQUARE");
		s3.draw();
	}
}

```



## 抽象工厂模式

抽象工厂模式是围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一个创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显示指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

### 示例代码

为形状创建一个接口

`Shape.java`

```java
package abstractFactoryPattern;

public interface Shape {
	void draw();
}

```



创建实现shape接口的实体类

Rectangle.java

```java
package abstractFactoryPattern;

public class Rectangle implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Rectangle::draw() method");
	}

}

```



Square.java

```java
package abstractFactoryPattern;

public class Square implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Square::draw() method");
	}

}

```



Cirlce.java

```java
package abstractFactoryPattern;

public class Circle implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Circle::draw() method");
	}

}

```



为颜色创建一个接口

Color.java

```java
package abstractFactoryPattern;

public interface Color {
	void fill();
}

```



创建实现Color接口的实体类

Red.java

```java
package abstractFactoryPattern;

public class Red implements Color {

	@Override
	public void fill() {
		System.out.println("Inside Red::fill() method");
	}

}

```



Green.java

```java
package abstractFactoryPattern;

public class Green implements Color {

	@Override
	public void fill() {
		System.out.println("Inside Green::fill() method");
	}

}

```



Blue.java

```java
package abstractFactoryPattern;

public class Blue implements Color {

	@Override
	public void fill() {
		System.out.println("Inside Blue::fill() method");
	}

}

```



为Color和Shape对象创建抽象类来获取工厂

AbstractFactory.java

```java
package abstractFactoryPattern;

public abstract class AbstractFactory {
	abstract Color getColor(String color);

	abstract Shape getShape(String shape);
}

```



创建扩展了AbstractFactory的工厂类，基于给定的信息生成实体类的对象

ShapeFactory.java

```java
package abstractFactoryPattern;

public class ShapeFactory extends AbstractFactory {

	@Override
	Shape getShape(String shapeType) {
		if (shapeType == null) {
			return null;
		}

		if (shapeType.equalsIgnoreCase("CIRCLE")) {
			return new Circle();
		} else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
			return new Rectangle();
		} else if (shapeType.equalsIgnoreCase("SQUARE")) {
			return new Square();
		}

		return null;
	}

	@Override
	Color getColor(String color) {
		return null;
	}

}

```



ColorFactory.java

```java
package abstractFactoryPattern;

public class ColorFactory extends AbstractFactory {

	@Override
	Color getColor(String color) {
		if (color == null) {
			return null;
		}

		if (color.equalsIgnoreCase("RED")) {
			return new Red();
		} else if (color.equalsIgnoreCase("GREEN")) {
			return new Green();
		} else if (color.equalsIgnoreCase("BLUE")) {
			return new Blue();
		}

		return null;
	}

	@Override
	Shape getShape(String shape) {
		return null;
	}

}

```



创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂

FactoryProducer.java

```java
package abstractFactoryPattern;

public class FactoryProducer {
	public static AbstractFactory getFactory(String choice) {
		if (choice.equalsIgnoreCase("SHAPE")) {
			return new ShapeFactory();
		} else if (choice.equalsIgnoreCase("COLOR")) {
			return new ColorFactory();
		}

		return null;
	}
}

```



使用FactoryProducer来获取AbstractFactory，通过传递类型信息来获取实体类的对象。

AbstractFactoryPatternDemo.java

```java
package abstractFactoryPattern;

public class AbstractFactoryPatternDemo {
	public static void main(String[] args) {
		AbstractFactory sf = FactoryProducer.getFactory("SHAPE");

		Shape s1 = sf.getShape("CIRCLE");
		s1.draw();

		Shape s2 = sf.getShape("RECTANGLE");
		s2.draw();

		Shape s3 = sf.getShape("SQUARE");
		s3.draw();

		AbstractFactory cf = FactoryProducer.getFactory("COLOR");

		Color c1 = cf.getColor("RED");
		c1.fill();

		Color c2 = cf.getColor("GREEN");
		c2.fill();

		Color c3 = cf.getColor("BLUE");
		c3.fill();
	}
}

```



## 单例模式

单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象

**注意**

+ 单例类只能有一个实例
+ 单例类必须自己创建自己的唯一实例
+ 单例必须给所有其他对象提供这一实例

### 示例代码

创建一个Singleton类

SingleObject.java

```java
package singletonPattern;

public class SingleObject {

	private static SingleObject instance = new SingleObject();

	private SingleObject() {
	}

	public static SingleObject getInstance() {
		return instance;
	}

	public void showMessage() {
		System.out.println("Hello World");
	}
}

```



从singleton类获取唯一的对象

SingletonPatternDemo.java

```java
package singletonPattern;

public class SingletonPatternDemo {
	public static void main(String[] args) {
		SingleObject obj = SingleObject.getInstance();
		obj.showMessage();
	}
}

```



### 单例模式的几种实现方式

#### 懒汉式，线程不安全

```java
package singletonPattern;

/**
 * 懒汉式，线程不安全
 * @author mark
 * @time 2018 下午2:47:16
 * @description 
 *
 */
public class Singleton {
	private static Singleton instance;

	private Singleton() {

	}

	public static Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}

		return instance;
	}
}

```



#### 懒汉式，线程安全

```java
package singletonPattern;

public class Singleton2 {
	private static Singleton2 instance;

	private Singleton2() {

	}

	public static synchronized Singleton2 getInstance() {
		if (instance == null) {
			instance = new Singleton2();
		}

		return instance;
	}
}

```



#### 饿汉式

```java
package singletonPattern;

/**
 * 饿汉式
 * @author mark
 * @time 2018 下午2:53:05
 * @description 
 *
 */
public class Singleton3 {
	private static Singleton3 instance = new Singleton3();

	private Singleton3() {

	}

	public static Singleton3 getInstance() {
		return instance;
	}
}

```



#### 双检锁/双重校验锁

```java
package singletonPattern;

/**
 * 双检锁/双重校验锁
 * @author mark
 * @time 2018 下午2:56:33
 * @description 
 *
 */
public class Singleton4 {
	private volatile static Singleton4 singleton;

	private Singleton4() {

	}

	public static Singleton4 getSingleton() {
		if (singleton == null) {
			synchronized (Singleton4.class) {
				if (singleton == null) {
					singleton = new Singleton4();
				}
			}
		}

		return singleton;
	}
}

```



#### 登记式/静态内部类

```java
package singletonPattern;

/**
 * 登记式/静态内部类
 * 
 * @author mark
 * @time 2018 下午3:00:59
 * @description 
 *
 */
public class Singleton5 {
	private static class SingletonHolder {
		private static final Singleton5 INSTANCE = new Singleton5();
	}

	private Singleton5() {

	}

	public static final Singleton5 getInstance() {
		return SingletonHolder.INSTANCE;
	}
}

```



#### 枚举

```java
package singletonPattern;

/**
 * 枚举
 * @author mark
 * @time 2018 下午3:03:03
 * @description 
 *
 */
public enum Singleton6 {
	INSTANCE;
	public void whateverMethod() {

	}
}

```



## 建造者模式

建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个Builder类会一步一步构造最终的对象，该Builder类是独立于其他对象的。

### 示例代码

创建一个表示食物条目和食物包装的接口

Item.java

```java
package builderPattern;

public interface Item {
	public String name();

	public Packing packing();

	public float price();
}

```

Packing.java

```java
package builderPattern;

public interface Packing {
	public String pack();
}

```



创建实现Packing接口的实体类

Wrapper.java

```java
package builderPattern;

public class Wrapper implements Packing {

	@Override
	public String pack() {
		return "Wrapper";
	}

}

```

Bottle.java

```java
package builderPattern;

public class Bottle implements Packing {

	@Override
	public String pack() {
		return "Bottle";
	}

}

```



创建实现Item接口的抽象类，该类提供了默认的功能

Burger.java

```java
package builderPattern;

public abstract class Burger implements Item {

	@Override
	public Packing packing() {
		return new Wrapper();
	}

}

```

ColdDrink.java

```java
package builderPattern;

public abstract class ColdDrink implements Item {

	@Override
	public Packing packing() {
		return new Bottle();
	}

}

```



创建扩展了Burger和ColdDrink的实体类

VegBurger.java

```java
package builderPattern;

public class VegBurger extends Burger {

	@Override
	public String name() {
		return "Veg Burger";
	}

	@Override
	public float price() {
		return 25f;
	}

}

```

ChickenBurger.java

```java
package builderPattern;

public class ChickenBurger extends Burger {

	@Override
	public String name() {
		return "Chicken Burger";
	}

	@Override
	public float price() {
		return 50.5f;
	}

}

```

Coke.java

```java
package builderPattern;

public class Coke extends ColdDrink {

	@Override
	public String name() {
		return "Coke";
	}

	@Override
	public float price() {
		return 30f;
	}

}

```

Pepsi.java

```java
package builderPattern;

public class Pepsi extends ColdDrink {

	@Override
	public String name() {
		return "Pepsi";
	}

	@Override
	public float price() {
		return 35f;
	}

}

```



创建一个Meal类，带有上面定义的Item对象

Meal.java

```java
package builderPattern;

import java.util.ArrayList;
import java.util.List;

public class Meal {
	private List<Item> items = new ArrayList<Item>();

	public void addItem(Item item) {
		items.add(item);
	}

	public float getCost() {
		float cost = 0f;

		for (Item item : items) {
			cost += item.price();
		}

		return cost;
	}

	public void showItem() {
		for (Item item : items) {
			System.out.print("Item : " + item.name());
			System.out.print(" , Packing : " + item.packing().pack());
			System.out.println(" , Price : " + item.price());
		}
	}
}

```



创建一个MealBuilder类，实际的builder类负责创建Meal对象

MealBuilder.java

```java
package builderPattern;

public class MealBuilder {

	public Meal prepareVegMeal() {
		Meal meal = new Meal();
		meal.addItem(new VegBurger());
		meal.addItem(new Coke());
		return meal;
	}

	public Meal prepareNonVegMeal() {
		Meal meal = new Meal();
		meal.addItem(new ChickenBurger());
		meal.addItem(new Pepsi());
		return meal;
	}
}

```



BuilderPatternDemo使用MealBuilder来演示建造者模式

BuilderPatternDemo.java

```java
package builderPattern;

public class BuilderPatternDemo {

	public static void main(String[] args) {
		MealBuilder mb = new MealBuilder();

		Meal vegMeal = mb.prepareVegMeal();
		System.out.println("Veg Meal");
		vegMeal.showItem();
		System.out.println("Total Cost: " + vegMeal.getCost());

		Meal nonVegMeal = mb.prepareNonVegMeal();
		System.out.println("Non-Veg Meal");
		nonVegMeal.showItem();
		System.out.println("Total Cost: " + nonVegMeal.getCost());
	}
}

```



## 原型模式

原型模式是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

**注意事项**：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现Cloneable，重写clone()，深拷贝是通过实现Serializable读取二进制流



### 示例代码

创建一个实现了Clonable接口的抽象类

Shape.java

```java
package prototypePattern;

public abstract class Shape implements Cloneable {
	private String id;
	protected String type;

	abstract void draw();

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	@Override
	public Object clone() {
		Object clone = null;

		try {
			clone = super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}

		return clone;
	}
}

```



创建扩展了上面抽象类的实体类

Rectangle.java

```java
package prototypePattern;

public class Rectangle extends Shape {

	public Rectangle() {
		type = "Rectangle";
	}

	@Override
	void draw() {
		System.out.println("Inside Rectangle::draw() method");
	}

}

```

Square.java

```java
package prototypePattern;

public class Square extends Shape {

	public Square() {
		type = "Square";
	}

	@Override
	void draw() {
		System.out.println("Inside Square::draw() method");
	}

}

```

Circle.java

```java
package prototypePattern;

public class Circle extends Shape {

	public Circle() {
		type = "Circle";
	}

	@Override
	void draw() {
		System.out.println("Inside Circle::draw() method");
	}

}

```





创建一个类，从数据库获取实体类，并把它们存储在一个Hashtable中

ShapeCache.java

```java
package prototypePattern;

import java.util.Hashtable;

public class ShapeCache {

	private static Hashtable<String, Shape> shapeMap = new Hashtable<String, Shape>();

	public static Shape getShape(String shapeId) {
		Shape cachedShape = shapeMap.get(shapeId);
		return (Shape) cachedShape.clone();
	}

	public static void loadCache() {
		Circle circle = new Circle();
		circle.setId("1");
		shapeMap.put(circle.getId(), circle);

		Square square = new Square();
		square.setId("2");
		shapeMap.put(square.getId(), square);

		Rectangle rectangle = new Rectangle();
		rectangle.setId("3");
		shapeMap.put(rectangle.getId(), rectangle);
	}
}

```



PrototypePatternDemo使用ShapeCache类来获取存储在Hashtable中的形状的克隆

PrototypePatternDemo.java

```java
package prototypePattern;

public class PrototypePatternDemo {

	public static void main(String[] args) {
		ShapeCache.loadCache();

		Shape cloneShape = ShapeCache.getShape("1");
		System.out.println("Shape : " + cloneShape.getType());

		Shape cloneShape2 = ShapeCache.getShape("2");
		System.out.println("Shape : " + cloneShape2.getType());

		Shape cloneShape3 = ShapeCache.getShape("3");
		System.out.println("Shape : " + cloneShape3.getType());
	}
}

```



## 适配器模式

适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。



### 示例代码

为媒体播放器和更高级的媒体播放器创建接口

MediaPlayer.java

```java
package adapterPattern;

public interface MediaPlayer {
	public void play(String audioType, String fileName);
}

```

AdvancedMediaPlayer.java

```java
package adapterPattern;

public interface AdvancedMediaPlayer {
	public void playVlc(String fileName);

	public void playMp4(String fileName);
}

```



创建实现了AdvancedMediaPlayer接口的实体类

VlcPlayer.java

```java
package adapterPattern;

public class VlcPlayer implements AdvancedMediaPlayer {

	@Override
	public void playVlc(String fileName) {
		System.out.println("Playing vlc file, Name: " + fileName);
	}

	@Override
	public void playMp4(String fileName) {

	}

}

```

Mp4Player.java

```java
package adapterPattern;

public class Mp4Player implements AdvancedMediaPlayer {

	@Override
	public void playVlc(String fileName) {

	}

	@Override
	public void playMp4(String fileName) {
		System.out.println("Playing mp4 file, Name: " + fileName);
	}

}

```



创建实现了MediaPlayer接口的适配器类

MediaAdapter.java

```java
package adapterPattern;

public class MediaAdapter implements MediaPlayer {

	AdvancedMediaPlayer amp;

	public MediaAdapter(String audioType) {
		if (audioType.equalsIgnoreCase("vlc")) {
			amp = new VlcPlayer();
		} else if (audioType.equalsIgnoreCase("mp4")) {
			amp = new Mp4Player();
		}
	}

	@Override
	public void play(String audioType, String fileName) {
		if(audioType.equalsIgnoreCase("vlc")) {
			amp.playVlc(fileName);
		}else if(audioType.equalsIgnoreCase("mp4")) {
			amp.playMp4(fileName);
		}
	}

}

```



创建实现了MediaPlayer接口的实体类

AudioPlayer.java

```java
package adapterPattern;

public class AudioPlayer implements MediaPlayer {

	MediaAdapter ma;

	@Override
	public void play(String audioType, String fileName) {
		if (audioType.equalsIgnoreCase("mp3")) {
			System.out.println("Playing mp3 file. Name: " + fileName);
		} else if (audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")) {
			ma = new MediaAdapter(audioType);
			ma.play(audioType, fileName);
		} else {
			System.out.println("Invalid media. " + audioType + " format not supported");
		}
	}

}

```



使用AudioPlayer来播放不同类型的音频格式

AdapterPatternDemo.java

```java
package adapterPattern;

public class AdapterPatternDemo {
	public static void main(String[] args) {
		AudioPlayer ap = new AudioPlayer();

		ap.play("mp3", "beyond the horizon.mp3");
		ap.play("mp4", "alone.mp4");
		ap.play("vlc", "far far away.vlc");
		ap.play("avi", "mind me.avi");
	}
}

```



## 桥接模式

桥接是用于把抽象化与实现化解耦，使得二者可以独立变化，这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦



