# 设计模式

## 面向对象设计原则

+ 对接口编程而不是对实现编程
+ 优先使用对象组合而不是继承



## 设计模式的类型

总共有23中设计模式，分为三大类：创建型模式(Creational Patterns)、结构型模式(Structural Patterns)，行为型模式(Behavioral Patterns)。同时，也讨论另一类设计模式：J2EE设计模式

| 序号 | 模式 & 描述                                                  | 包括                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | 创建型模式<br />这些设计模式提供了一种在创建对象在同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活 | 工厂模式<br />抽象工厂模式<br />单例模式<br />建造者模式<br />原型模式 |
| 2    | 结构型模式<br />这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式 | 适配器模式<br />桥接模式<br />过滤器模式<br />组合模式<br />装饰器模式<br />外观模式<br />享元模式<br />代理模式 |
| 3    | 行为型模式<br />这些设计模式特别关注对象之间的通信           | 责任链模式<br />命令模式<br />解释器模式<br />迭代器模式<br />中介者模式<br />备忘录模式<br />观察者模式<br />状态模式<br />空对象模式<br />策略模式<br />模板模式<br />访问者模式 |
| 4    | J2EE模式<br />这些设计模式特别关注表示层。这些模式是由Sun Java Center鉴定在 | MVC模式<br />业务代表模式<br />组合实体模式<br />数据访问对象模式<br />前端控制器模式<br />拦截过滤器模式<br />服务定位器模式<br />传输对象模式 |

创建型模式 -> 对象怎么来

结构型模式 -> 对象和谁有关

行为型模式 -> 对象与对象在干嘛

J2EE模式 -> 对象合起来要干嘛



## 设计模式在六大原则

1. 开闭原则：**对扩展开放，对修改关闭。**实现热插拔，提高扩展性
2. 里氏代换原则：实现抽象的规范，实现子父类互相替换
3. 依赖倒转原则：针对接口编程，实现开闭原则的基础
4. 接口隔离原则：降低耦合度，接口单独设计，互相隔离
5. 迪米特法则：又称不知道原则：功能模块尽力独立
6. 合成复用原则：尽量使用聚合，组合，而不是继承



## 工厂模式

创建对象时不会对客户端暴露创建逻辑，并且通过使用一个共同的接口来指向新创建的对象

### 示例代码

创建接口`Shape.java`

```java
package factoryPattern;

public interface Shape {
	void draw();
}

```



创建实现接口的实体类

`Rectangle.java`

```java
package factoryPattern;

public class Rectangle implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Rectangle::draw() method");
	}

}

```



`Square.java`

```java
package factoryPattern;

public class Square implements Shape{

	@Override
	public void draw() {
		System.out.println("Inside Square::draw() method");
	}
	
}

```



`Circle.java`

```java
package factoryPattern;

public class Circle implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Circle::draw() method");
	}

}

```



创建一个工厂，生成基于给定信息的实体类的对象

`ShapeFactory.java`

```java
package factoryPattern;

public class ShapeFactory {
	public Shape getShape(String shapeType) {
		if (shapeType == null) {
			return null;
		}

		if (shapeType.equalsIgnoreCase("CIRCLE")) {
			return new Circle();
		} else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
			return new Rectangle();
		} else if (shapeType.equalsIgnoreCase("SQUARE")) {
			return new Square();
		}

		return null;
	}
}

```



使用该工厂，通过传递类型信息来获取实体类的对象

`FactoryPatternDemo.java`

```java
package factoryPattern;

public class FactoryPatternDemo {
	public static void main(String[] args) {
		ShapeFactory sf = new ShapeFactory();

		Shape s1 = sf.getShape("CIRCLE");
		s1.draw();

		Shape s2 = sf.getShape("RECTANGLE");
		s2.draw();

		Shape s3 = sf.getShape("SQUARE");
		s3.draw();
	}
}

```



## 抽象工厂模式

抽象工厂模式是围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一个创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显示指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

### 示例代码

为形状创建一个接口

`Shape.java`

```java
package abstractFactoryPattern;

public interface Shape {
	void draw();
}

```



创建实现shape接口的实体类

Rectangle.java

```java
package abstractFactoryPattern;

public class Rectangle implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Rectangle::draw() method");
	}

}

```



Square.java

```java
package abstractFactoryPattern;

public class Square implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Square::draw() method");
	}

}

```



Cirlce.java

```java
package abstractFactoryPattern;

public class Circle implements Shape {

	@Override
	public void draw() {
		System.out.println("Inside Circle::draw() method");
	}

}

```



为颜色创建一个接口

Color.java

```java
package abstractFactoryPattern;

public interface Color {
	void fill();
}

```



创建实现Color接口的实体类

Red.java

```java
package abstractFactoryPattern;

public class Red implements Color {

	@Override
	public void fill() {
		System.out.println("Inside Red::fill() method");
	}

}

```



Green.java

```java
package abstractFactoryPattern;

public class Green implements Color {

	@Override
	public void fill() {
		System.out.println("Inside Green::fill() method");
	}

}

```



Blue.java

```java
package abstractFactoryPattern;

public class Blue implements Color {

	@Override
	public void fill() {
		System.out.println("Inside Blue::fill() method");
	}

}

```



为Color和Shape对象创建抽象类来获取工厂

AbstractFactory.java

```java
package abstractFactoryPattern;

public abstract class AbstractFactory {
	abstract Color getColor(String color);

	abstract Shape getShape(String shape);
}

```



创建扩展了AbstractFactory的工厂类，基于给定的信息生成实体类的对象

ShapeFactory.java

```java
package abstractFactoryPattern;

public class ShapeFactory extends AbstractFactory {

	@Override
	Shape getShape(String shapeType) {
		if (shapeType == null) {
			return null;
		}

		if (shapeType.equalsIgnoreCase("CIRCLE")) {
			return new Circle();
		} else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
			return new Rectangle();
		} else if (shapeType.equalsIgnoreCase("SQUARE")) {
			return new Square();
		}

		return null;
	}

	@Override
	Color getColor(String color) {
		return null;
	}

}

```



ColorFactory.java

```java
package abstractFactoryPattern;

public class ColorFactory extends AbstractFactory {

	@Override
	Color getColor(String color) {
		if (color == null) {
			return null;
		}

		if (color.equalsIgnoreCase("RED")) {
			return new Red();
		} else if (color.equalsIgnoreCase("GREEN")) {
			return new Green();
		} else if (color.equalsIgnoreCase("BLUE")) {
			return new Blue();
		}

		return null;
	}

	@Override
	Shape getShape(String shape) {
		return null;
	}

}

```



创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂

FactoryProducer.java

```java
package abstractFactoryPattern;

public class FactoryProducer {
	public static AbstractFactory getFactory(String choice) {
		if (choice.equalsIgnoreCase("SHAPE")) {
			return new ShapeFactory();
		} else if (choice.equalsIgnoreCase("COLOR")) {
			return new ColorFactory();
		}

		return null;
	}
}

```



使用FactoryProducer来获取AbstractFactory，通过传递类型信息来获取实体类的对象。

AbstractFactoryPatternDemo.java

```java
package abstractFactoryPattern;

public class AbstractFactoryPatternDemo {
	public static void main(String[] args) {
		AbstractFactory sf = FactoryProducer.getFactory("SHAPE");

		Shape s1 = sf.getShape("CIRCLE");
		s1.draw();

		Shape s2 = sf.getShape("RECTANGLE");
		s2.draw();

		Shape s3 = sf.getShape("SQUARE");
		s3.draw();

		AbstractFactory cf = FactoryProducer.getFactory("COLOR");

		Color c1 = cf.getColor("RED");
		c1.fill();

		Color c2 = cf.getColor("GREEN");
		c2.fill();

		Color c3 = cf.getColor("BLUE");
		c3.fill();
	}
}

```



## 单例模式

单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象

**注意**

+ 单例类只能有一个实例
+ 单例类必须自己创建自己的唯一实例
+ 单例必须给所有其他对象提供这一实例

### 示例代码

创建一个Singleton类

SingleObject.java

```java
package singletonPattern;

public class SingleObject {

	private static SingleObject instance = new SingleObject();

	private SingleObject() {
	}

	public static SingleObject getInstance() {
		return instance;
	}

	public void showMessage() {
		System.out.println("Hello World");
	}
}

```



从singleton类获取唯一的对象

SingletonPatternDemo.java

```java
package singletonPattern;

public class SingletonPatternDemo {
	public static void main(String[] args) {
		SingleObject obj = SingleObject.getInstance();
		obj.showMessage();
	}
}

```



### 单例模式的几种实现方式

#### 懒汉式，线程不安全

```java
package singletonPattern;

/**
 * 懒汉式，线程不安全
 * @author mark
 * @time 2018 下午2:47:16
 * @description 
 *
 */
public class Singleton {
	private static Singleton instance;

	private Singleton() {

	}

	public static Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}

		return instance;
	}
}

```



#### 懒汉式，线程安全

```java
package singletonPattern;

public class Singleton2 {
	private static Singleton2 instance;

	private Singleton2() {

	}

	public static synchronized Singleton2 getInstance() {
		if (instance == null) {
			instance = new Singleton2();
		}

		return instance;
	}
}

```



#### 饿汉式

```java
package singletonPattern;

/**
 * 饿汉式
 * @author mark
 * @time 2018 下午2:53:05
 * @description 
 *
 */
public class Singleton3 {
	private static Singleton3 instance = new Singleton3();

	private Singleton3() {

	}

	public static Singleton3 getInstance() {
		return instance;
	}
}

```



#### 双检锁/双重校验锁

```java
package singletonPattern;

/**
 * 双检锁/双重校验锁
 * @author mark
 * @time 2018 下午2:56:33
 * @description 
 *
 */
public class Singleton4 {
	private volatile static Singleton4 singleton;

	private Singleton4() {

	}

	public static Singleton4 getSingleton() {
		if (singleton == null) {
			synchronized (Singleton4.class) {
				if (singleton == null) {
					singleton = new Singleton4();
				}
			}
		}

		return singleton;
	}
}

```



#### 登记式/静态内部类

```java
package singletonPattern;

/**
 * 登记式/静态内部类
 * 
 * @author mark
 * @time 2018 下午3:00:59
 * @description 
 *
 */
public class Singleton5 {
	private static class SingletonHolder {
		private static final Singleton5 INSTANCE = new Singleton5();
	}

	private Singleton5() {

	}

	public static final Singleton5 getInstance() {
		return SingletonHolder.INSTANCE;
	}
}

```



#### 枚举

```java
package singletonPattern;

/**
 * 枚举
 * @author mark
 * @time 2018 下午3:03:03
 * @description 
 *
 */
public enum Singleton6 {
	INSTANCE;
	public void whateverMethod() {

	}
}

```



## 建造者模式

建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

一个Builder类会一步一步构造最终的对象，该Builder类是独立于其他对象的。

### 示例代码

创建一个表示食物条目和食物包装的接口

Item.java

```java
package builderPattern;

public interface Item {
	public String name();

	public Packing packing();

	public float price();
}

```

Packing.java

```java
package builderPattern;

public interface Packing {
	public String pack();
}

```



创建实现Packing接口的实体类

Wrapper.java

```java
package builderPattern;

public class Wrapper implements Packing {

	@Override
	public String pack() {
		return "Wrapper";
	}

}

```

Bottle.java

```java
package builderPattern;

public class Bottle implements Packing {

	@Override
	public String pack() {
		return "Bottle";
	}

}

```



创建实现Item接口的抽象类，该类提供了默认的功能

Burger.java

```java
package builderPattern;

public abstract class Burger implements Item {

	@Override
	public Packing packing() {
		return new Wrapper();
	}

}

```

ColdDrink.java

```java
package builderPattern;

public abstract class ColdDrink implements Item {

	@Override
	public Packing packing() {
		return new Bottle();
	}

}

```



创建扩展了Burger和ColdDrink的实体类

VegBurger.java

```java
package builderPattern;

public class VegBurger extends Burger {

	@Override
	public String name() {
		return "Veg Burger";
	}

	@Override
	public float price() {
		return 25f;
	}

}

```

ChickenBurger.java

```java
package builderPattern;

public class ChickenBurger extends Burger {

	@Override
	public String name() {
		return "Chicken Burger";
	}

	@Override
	public float price() {
		return 50.5f;
	}

}

```

Coke.java

```java
package builderPattern;

public class Coke extends ColdDrink {

	@Override
	public String name() {
		return "Coke";
	}

	@Override
	public float price() {
		return 30f;
	}

}

```

Pepsi.java

```java
package builderPattern;

public class Pepsi extends ColdDrink {

	@Override
	public String name() {
		return "Pepsi";
	}

	@Override
	public float price() {
		return 35f;
	}

}

```



创建一个Meal类，带有上面定义的Item对象

Meal.java

```java
package builderPattern;

import java.util.ArrayList;
import java.util.List;

public class Meal {
	private List<Item> items = new ArrayList<Item>();

	public void addItem(Item item) {
		items.add(item);
	}

	public float getCost() {
		float cost = 0f;

		for (Item item : items) {
			cost += item.price();
		}

		return cost;
	}

	public void showItem() {
		for (Item item : items) {
			System.out.print("Item : " + item.name());
			System.out.print(" , Packing : " + item.packing().pack());
			System.out.println(" , Price : " + item.price());
		}
	}
}

```



创建一个MealBuilder类，实际的builder类负责创建Meal对象

MealBuilder.java

```java
package builderPattern;

public class MealBuilder {

	public Meal prepareVegMeal() {
		Meal meal = new Meal();
		meal.addItem(new VegBurger());
		meal.addItem(new Coke());
		return meal;
	}

	public Meal prepareNonVegMeal() {
		Meal meal = new Meal();
		meal.addItem(new ChickenBurger());
		meal.addItem(new Pepsi());
		return meal;
	}
}

```



BuilderPatternDemo使用MealBuilder来演示建造者模式

BuilderPatternDemo.java

```java
package builderPattern;

public class BuilderPatternDemo {

	public static void main(String[] args) {
		MealBuilder mb = new MealBuilder();

		Meal vegMeal = mb.prepareVegMeal();
		System.out.println("Veg Meal");
		vegMeal.showItem();
		System.out.println("Total Cost: " + vegMeal.getCost());

		Meal nonVegMeal = mb.prepareNonVegMeal();
		System.out.println("Non-Veg Meal");
		nonVegMeal.showItem();
		System.out.println("Total Cost: " + nonVegMeal.getCost());
	}
}

```



## 原型模式

原型模式是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

**注意事项**：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现Cloneable，重写clone()，深拷贝是通过实现Serializable读取二进制流



### 示例代码

创建一个实现了Clonable接口的抽象类

Shape.java

```java
package prototypePattern;

public abstract class Shape implements Cloneable {
	private String id;
	protected String type;

	abstract void draw();

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	@Override
	public Object clone() {
		Object clone = null;

		try {
			clone = super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}

		return clone;
	}
}

```



创建扩展了上面抽象类的实体类

Rectangle.java

```java
package prototypePattern;

public class Rectangle extends Shape {

	public Rectangle() {
		type = "Rectangle";
	}

	@Override
	void draw() {
		System.out.println("Inside Rectangle::draw() method");
	}

}

```

Square.java

```java
package prototypePattern;

public class Square extends Shape {

	public Square() {
		type = "Square";
	}

	@Override
	void draw() {
		System.out.println("Inside Square::draw() method");
	}

}

```

Circle.java

```java
package prototypePattern;

public class Circle extends Shape {

	public Circle() {
		type = "Circle";
	}

	@Override
	void draw() {
		System.out.println("Inside Circle::draw() method");
	}

}

```





创建一个类，从数据库获取实体类，并把它们存储在一个Hashtable中

ShapeCache.java

```java
package prototypePattern;

import java.util.Hashtable;

public class ShapeCache {

	private static Hashtable<String, Shape> shapeMap = new Hashtable<String, Shape>();

	public static Shape getShape(String shapeId) {
		Shape cachedShape = shapeMap.get(shapeId);
		return (Shape) cachedShape.clone();
	}

	public static void loadCache() {
		Circle circle = new Circle();
		circle.setId("1");
		shapeMap.put(circle.getId(), circle);

		Square square = new Square();
		square.setId("2");
		shapeMap.put(square.getId(), square);

		Rectangle rectangle = new Rectangle();
		rectangle.setId("3");
		shapeMap.put(rectangle.getId(), rectangle);
	}
}

```



PrototypePatternDemo使用ShapeCache类来获取存储在Hashtable中的形状的克隆

PrototypePatternDemo.java

```java
package prototypePattern;

public class PrototypePatternDemo {

	public static void main(String[] args) {
		ShapeCache.loadCache();

		Shape cloneShape = ShapeCache.getShape("1");
		System.out.println("Shape : " + cloneShape.getType());

		Shape cloneShape2 = ShapeCache.getShape("2");
		System.out.println("Shape : " + cloneShape2.getType());

		Shape cloneShape3 = ShapeCache.getShape("3");
		System.out.println("Shape : " + cloneShape3.getType());
	}
}

```



## 适配器模式

适配器模式是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。



### 示例代码

为媒体播放器和更高级的媒体播放器创建接口

MediaPlayer.java

```java
package adapterPattern;

public interface MediaPlayer {
	public void play(String audioType, String fileName);
}

```

AdvancedMediaPlayer.java

```java
package adapterPattern;

public interface AdvancedMediaPlayer {
	public void playVlc(String fileName);

	public void playMp4(String fileName);
}

```



创建实现了AdvancedMediaPlayer接口的实体类

VlcPlayer.java

```java
package adapterPattern;

public class VlcPlayer implements AdvancedMediaPlayer {

	@Override
	public void playVlc(String fileName) {
		System.out.println("Playing vlc file, Name: " + fileName);
	}

	@Override
	public void playMp4(String fileName) {

	}

}

```

Mp4Player.java

```java
package adapterPattern;

public class Mp4Player implements AdvancedMediaPlayer {

	@Override
	public void playVlc(String fileName) {

	}

	@Override
	public void playMp4(String fileName) {
		System.out.println("Playing mp4 file, Name: " + fileName);
	}

}

```



创建实现了MediaPlayer接口的适配器类

MediaAdapter.java

```java
package adapterPattern;

public class MediaAdapter implements MediaPlayer {

	AdvancedMediaPlayer amp;

	public MediaAdapter(String audioType) {
		if (audioType.equalsIgnoreCase("vlc")) {
			amp = new VlcPlayer();
		} else if (audioType.equalsIgnoreCase("mp4")) {
			amp = new Mp4Player();
		}
	}

	@Override
	public void play(String audioType, String fileName) {
		if(audioType.equalsIgnoreCase("vlc")) {
			amp.playVlc(fileName);
		}else if(audioType.equalsIgnoreCase("mp4")) {
			amp.playMp4(fileName);
		}
	}

}

```



创建实现了MediaPlayer接口的实体类

AudioPlayer.java

```java
package adapterPattern;

public class AudioPlayer implements MediaPlayer {

	MediaAdapter ma;

	@Override
	public void play(String audioType, String fileName) {
		if (audioType.equalsIgnoreCase("mp3")) {
			System.out.println("Playing mp3 file. Name: " + fileName);
		} else if (audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")) {
			ma = new MediaAdapter(audioType);
			ma.play(audioType, fileName);
		} else {
			System.out.println("Invalid media. " + audioType + " format not supported");
		}
	}

}

```



使用AudioPlayer来播放不同类型的音频格式

AdapterPatternDemo.java

```java
package adapterPattern;

public class AdapterPatternDemo {
	public static void main(String[] args) {
		AudioPlayer ap = new AudioPlayer();

		ap.play("mp3", "beyond the horizon.mp3");
		ap.play("mp4", "alone.mp4");
		ap.play("vlc", "far far away.vlc");
		ap.play("avi", "mind me.avi");
	}
}

```



## 桥接模式

桥接把抽象化和实现化分开，结构型模式



### 示例代码

创建桥接实现接口

DrawAPI.java

```java
package bridge;

public interface DrawAPI {
	public void drawCircle(int radius, int x, int y);
}

```



创建实现了DrawAPI接口是实体桥接实现类

RedCircle.java

```java
package bridge;

public class RedCircle implements DrawAPI {

	@Override
	public void drawCircle(int radius, int x, int y) {
		System.out.println("Drawing Circle[ color: red, radius: " + radius + ", x: " + x + " , " + y + "]");
	}

}

```

GreenCircle.java

```java
package bridge;

public class GreenCircle implements DrawAPI {

	@Override
	public void drawCircle(int radius, int x, int y) {
		System.out.println("Drawing Circle[ color: green, radius: " + radius + " , x: " + x + " , " + y + "]");
	}

}

```



使用DrawAPI接口创建抽象类Shape

Shape.java

```java
package bridge;

public abstract class Shape {
	protected DrawAPI drawAPI;

	protected Shape(DrawAPI drawAPI) {
		this.drawAPI = drawAPI;
	}

	public abstract void draw();
}

```



创建实现了Shape接口的实体类

Circle.java

```java
package bridge;

public class Circle extends Shape {
	private int x, y, radius;

	protected Circle(int x, int y, int radius, DrawAPI drawAPI) {
		super(drawAPI);
		this.x = x;
		this.y = y;
		this.radius = radius;
	}

	@Override
	public void draw() {
		drawAPI.drawCircle(radius, x, y);
	}

}

```



使用Shape和DrawAPI类画出不同颜色的圆

BridgePatternDemo.java

```java
package bridge;

public class BridgePatternDemo {

	public static void main(String[] args) {
		Shape redCircle = new Circle(100, 100, 10, new RedCircle());
		Shape greenCircle = new Circle(100, 100, 10, new GreenCircle());

		redCircle.draw();
		greenCircle.draw();
	}
}

```



## 过滤器模式

使用不同标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来，结构型模式

### 示例代码

创建一个类，在该类上应用标准

Person.java

```java
package filterPattern;

public class Person {
	private String name;
	private String gender;
	private String maritalStatus;

	public Person(String name, String gender, String maritalStatus) {
		super();
		this.name = name;
		this.gender = gender;
		this.maritalStatus = maritalStatus;
	}

	public String getName() {
		return name;
	}

	public String getGender() {
		return gender;
	}

	public String getMaritalStatus() {
		return maritalStatus;
	}

}

```



为标准(Criteria)创建一个接口

Criteria.java

```java
package filterPattern;

import java.util.List;

public interface Criteria {
	public List<Person> meetCriteria(List<Person> persons);
}

```



创建实现了Criteria接口的实体类

CriteriaMale.java

```java
package filterPattern;

import java.util.ArrayList;
import java.util.List;

public class CriteriaMale implements Criteria {

	@Override
	public List<Person> meetCriteria(List<Person> persons) {
		List<Person> malePersons = new ArrayList<Person>();

		for (Person person : persons) {
			if (person.getGender().equalsIgnoreCase("MALE")) {
				malePersons.add(person);
			}
		}

		return malePersons;
	}

}

```

CriteriaFemale.java

```java
package filterPattern;

import java.util.ArrayList;
import java.util.List;

public class CriteriaFemale implements Criteria {

	@Override
	public List<Person> meetCriteria(List<Person> persons) {
		List<Person> femalePersons = new ArrayList<Person>();

		for (Person person : persons) {
			if (person.getGender().equalsIgnoreCase("FEMALE")) {
				femalePersons.add(person);
			}
		}

		return femalePersons;
	}

}

```

CriteriaSingle.java

```java
package filterPattern;

import java.util.ArrayList;
import java.util.List;

public class CriteriaSingle implements Criteria {

	@Override
	public List<Person> meetCriteria(List<Person> persons) {
		List<Person> singlePersons = new ArrayList<Person>();

		for (Person person : persons) {
			if (person.getMaritalStatus().equalsIgnoreCase("SINGLE")) {
				singlePersons.add(person);
			}
		}

		return singlePersons;
	}

}

```

AndCriteria.java

```java
package filterPattern;

import java.util.List;

public class AndCriteria implements Criteria {
	private Criteria criteria;
	private Criteria otherCriteria;

	public AndCriteria(Criteria criteria, Criteria otherCriteria) {
		this.criteria = criteria;
		this.otherCriteria = otherCriteria;
	}

	@Override
	public List<Person> meetCriteria(List<Person> persons) {
		List<Person> firstCriteriaPersons = criteria.meetCriteria(persons);
		return otherCriteria.meetCriteria(firstCriteriaPersons);
	}

}

```

OrCriteria.java

```java
package filterPattern;

import java.util.List;

public class OrCriteria implements Criteria {
	private Criteria criteria;
	private Criteria otherCriteria;

	public OrCriteria(Criteria criteria, Criteria otherCriteria) {
		super();
		this.criteria = criteria;
		this.otherCriteria = otherCriteria;
	}

	@Override
	public List<Person> meetCriteria(List<Person> persons) {
		List<Person> firstCriteriaItems = criteria.meetCriteria(persons);
		List<Person> otherCriteriaItems = otherCriteria.meetCriteria(persons);

		for (Person person : otherCriteriaItems) {
			if (!firstCriteriaItems.contains(person)) {
				firstCriteriaItems.add(person);
			}
		}

		return firstCriteriaItems;
	}

}

```



使用不同的标准(Criteria)和它们的结合来过滤Person对象的列表

CriteriaPatternDemo.java

```java
package filterPattern;

import java.util.ArrayList;
import java.util.List;

public class CriteriaPatternDemo {

	public static void main(String[] args) {
		List<Person> persons = new ArrayList<Person>();

		persons.add(new Person("Robert", "Male", "Single"));
		persons.add(new Person("John", "Male", "Married"));
		persons.add(new Person("Laura", "Female", "Married"));
		persons.add(new Person("Diana", "Female", "Single"));
		persons.add(new Person("Mike", "Male", "Single"));
		persons.add(new Person("Bobby", "Male", "Single"));

		Criteria male = new CriteriaMale();
		Criteria female = new CriteriaFemale();
		Criteria single = new CriteriaSingle();
		Criteria singleMale = new AndCriteria(single, male);
		Criteria singleOrFemale = new OrCriteria(single, female);

		System.out.println("Males: ");
		printPersons(male.meetCriteria(persons));

		System.out.println("\nFemales: ");
		printPersons(female.meetCriteria(persons));

		System.out.println("\nSingle Males: ");
		printPersons(singleMale.meetCriteria(persons));

		System.out.println("\nSingle Or Females: ");
		printPersons(singleOrFemale.meetCriteria(persons));
	}

	public static void printPersons(List<Person> persons) {
		for (Person person : persons) {
			System.out.println("Person : [ Name : " + person.getName() + ", Gender : " + person.getGender()
					+ ", Marital Status : " + person.getMaritalStatus() + " ]");
		}
	}
}

```



## 组合模式

用树形结构来组合对象，表示部分以及整体层次，结构型模式

### 示例代码

创建Employee类，该类带有Employee对象的列表

Employee.java

```java
package compositePattern;

import java.util.ArrayList;
import java.util.List;

public class Employee {
	private String name;
	private String dept;
	private int salary;
	private List<Employee> subordinates;

	public Employee(String name, String dept, int sal) {
		this.name = name;
		this.dept = dept;
		this.salary = sal;
		subordinates = new ArrayList<Employee>();
	}

	public void add(Employee e) {
		subordinates.add(e);
	}

	public void remove(Employee e) {
		subordinates.remove(e);
	}

	public List<Employee> getSubordinates() {
		return subordinates;
	}

	@Override
	public String toString() {
		return ("Employee :[ Name : " + name + " , dept : " + dept + " , salary : " + salary + " ]");
	}
}

```



使用Employee类来创建和打印员工的层次结构

CompositePatternDemo.java

```java
package compositePattern;

public class CompositePatternDemo {

	public static void main(String[] args) {
		Employee CEO = new Employee("John", "CEO", 30000);

		Employee headSales = new Employee("Robert", "Head Sales", 20000);

		Employee headMarketing = new Employee("Michel", "Head Marketing", 20000);

		Employee clerk1 = new Employee("Laura", "Marketing", 10000);
		Employee clerk2 = new Employee("Bob", "Marketing", 10000);

		Employee salesExecutive1 = new Employee("Richard", "Sales", 10000);
		Employee salesExecutive2 = new Employee("Rob", "Sales", 10000);

		CEO.add(headSales);
		CEO.add(headMarketing);

		headSales.add(salesExecutive1);
		headSales.add(salesExecutive2);

		headMarketing.add(clerk1);
		headMarketing.add(clerk2);

		System.out.println(CEO);
		for (Employee headEmployee : CEO.getSubordinates()) {
			System.out.println(headEmployee);
			for (Employee employee : headEmployee.getSubordinates()) {
				System.out.println(employee);
			}
		}
	}
}

```



## 装饰器模式

向现有的对象添加新功能，但不改变其结构，结构型模式

### 示例代码

创建一个接口

Shape.java

```java
package decoratorPattern;

public interface Shape {
	void draw();
}

```



创建实现接口的实体类

Rectangle.java

```java
package decoratorPattern;

public class Rectangle implements Shape {

	@Override
	public void draw() {
		System.out.println("Shape: Rectangle");
	}

}

```

Circle.java

```java
package decoratorPattern;

public class Circle implements Shape {

	@Override
	public void draw() {
		System.out.println("Shape: Circle");
	}

}

```



创建实现了Shape接口的抽象装饰类

ShapeDecorator.java

```java
package decoratorPattern;

public abstract class ShapeDecorator implements Shape {
	protected Shape decoratedShape;

	public ShapeDecorator(Shape decoratedShape) {
		this.decoratedShape = decoratedShape;
	}

	@Override
	public void draw() {
		decoratedShape.draw();
	}

}

```



创建扩展了ShapeDecorator类的实体装饰类

RedShapeDecorator.java

```java
package decoratorPattern;

public class RedShapeDecorator extends ShapeDecorator {

	public RedShapeDecorator(Shape decoratedShape) {
		super(decoratedShape);
	}
	
	@Override
	public void draw() {
		decoratedShape.draw();
		setRedBorder(decoratedShape);
	}

	private void setRedBorder(Shape decoratedShape) {
		System.out.println("Border Color: Red");
	}
}

```



使用RedShapeDecorator来装饰Shape对象

DecoratorPatternDemo.java

```java
package decoratorPattern;

public class DecoratorPatternDemo {
	public static void main(String[] args) {
		Shape circle = new Circle();

		Shape redCircle = new RedShapeDecorator(new Circle());

		Shape redRectangle = new RedShapeDecorator(new Rectangle());

		System.out.println("Circle with normal border");
		circle.draw();

		System.out.println("\nCircle of red border");
		redCircle.draw();

		System.out.println("\nRectangle of red border");
		redRectangle.draw();
	}
}

```



## 外观模式

隐藏系统的复杂性，提供一个访问系统的接口，结构型模式

### 示例代码

创建一个接口

Shape.java

```java
package facadePattern;

public interface Shape {
	void draw();
}

```



创建实现接口的实体类

Rectangle.java

```java
package facadePattern;

public class Rectangle implements Shape {

	@Override
	public void draw() {
		System.out.println("Rectangle::draw()");
	}

}

```

Square.java

```java
package facadePattern;

public class Square implements Shape {

	@Override
	public void draw() {
		System.out.println("Square::draw()");
	}

}

```

Circle.java

```java
package facadePattern;

public class Circle implements Shape {

	@Override
	public void draw() {
		System.out.println("Circle::draw()");
	}

}

```



创建一个外观类

ShapeMaker.java

```java
package facadePattern;

public class ShapeMaker {
	private Shape circle;
	private Shape rectangle;
	private Shape square;

	public ShapeMaker() {
		circle = new Circle();
		rectangle = new Rectangle();
		square = new Square();
	}

	public void drawCircle() {
		circle.draw();
	}

	public void drawRectangle() {
		rectangle.draw();
	}

	public void drawSquare() {
		square.draw();
	}
}

```



使用该外观类画出各种类型的形状

FacadePatternDemo.java

```java
package facadePattern;

public class FacadePatternDemo {
	public static void main(String[] args) {
		ShapeMaker shapeMaker = new ShapeMaker();

		shapeMaker.drawCircle();
		shapeMaker.drawRectangle();
		shapeMaker.drawSquare();
	}
}

```



## 享元模式

结构型模式，减少创建对象的数量，以减少内存占用和提供性能

### 应用实例

Java的String类，数据库的数据池

### 示例代码

创建一个接口

Shape.java

```java
package flyweightPattern;

public interface Shape {
	void draw();
}

```



创建实现接口的实体类

Circle.java

```java
package flyweightPattern;

public class Circle implements Shape {
	private String color;
	private int x;
	private int y;
	private int radius;

	public Circle(String color) {
		this.color = color;
	}

	public void setX(int x) {
		this.x = x;
	}

	public void setY(int y) {
		this.y = y;
	}

	public void setRadius(int radius) {
		this.radius = radius;
	}

	@Override
	public void draw() {
		System.out
				.println("Circle: Draw() [Color : " + color + " , x : " + x + " , y : " + y + " , radius : " + radius);
	}

}

```



创建一个工厂，生成基于给定信息的实体类的对象

ShapeFactory.java

```java
package flyweightPattern;

import java.util.HashMap;

public class ShapeFactory {
	private static final HashMap<String, Shape> circleMap = new HashMap<>();

	public static Shape getCircle(String color) {
		Circle circle = (Circle) circleMap.get(color);

		if (circle == null) {
			circle = new Circle(color);
			circleMap.put(color, circle);
			System.out.println("Creating circle of color : " + color);
		}

		return circle;
	}
}

```



使用该工厂，通过传递颜色信息来获取实体类的对象

FlyweightPatternDemo.java

```java
package flyweightPattern;

public class FlyweightPatternDemo {
	private static final String[] colors = { "Red", "Green", "Blue", "White", "Black" };

	public static void main(String[] args) {
		for (int i = 0; i < 20; i++) {
			Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());
			circle.setX(getRandomX());
			circle.setY(getRandomY());
			circle.setRadius(100);
			circle.draw();
		}
	}

	private static String getRandomColor() {
		return colors[(int) (Math.random() * colors.length)];
	}

	private static int getRandomX() {
		return (int) (Math.random() * 100);
	}

	private static int getRandomY() {
		return (int) (Math.random() * 100);
	}
}

```



## 代理模式

结构型模式，一个类代表另一个类的功能，对一个类加以控制

### 应用实例

Windows快捷方式，Spring aop

### 示例代码

创建一个接口

Image.java

```java
package proxyPattern;

public interface Image {
	void display();
}

```



创建实现接口的实体类

RealImage.java

```java
package proxyPattern;

public class RealImage implements Image {
	private String fileName;

	public RealImage(String fileName) {
		this.fileName = fileName;
		loadFromDisk(fileName);
	}

	private void loadFromDisk(String fileName2) {
		System.out.println("Loading " + fileName);
	}

	@Override
	public void display() {
		System.out.println("Displaying " + fileName);
	}

}

```

ProxyImage.java

```java
package proxyPattern;

public class ProxyImage implements Image {
	private RealImage realImage;
	private String fileName;

	public ProxyImage(String fileName) {
		this.fileName = fileName;
	}

	@Override
	public void display() {
		if (realImage == null) {
			realImage = new RealImage(fileName);
		}
		realImage.display();
	}

}


```



当被请求时，使用ProxyImage来获取RealImage类的对象

ProxyPatternDemo.java

```java
package proxyPattern;

public class ProxyPatternDemo {

	public static void main(String[] args) {
		Image image = new ProxyImage("test_10mb.jpg");

		image.display();
		System.out.println();
		image.display();
	}
}

```



## 责任链模式

为请求创建一个接收者对象的链，行为型模式

### 应用实例

JS中的事件冒泡，Struts2的拦截器，jsp servlet的Filter

### 示例代码

创建抽象的记录器类

AbstractLogger.java

```java
package crPattern;

public abstract class AbstractLogger {
	public static int INFO = 1;
	public static int DEBUG = 2;
	public static int ERROR = 3;

	protected int level;

	protected AbstractLogger nextLogger;

	public void setNextLogger(AbstractLogger nextLogger) {
		this.nextLogger = nextLogger;
	}

	public void logMessage(int level, String message) {
		if (this.level <= level) {
			write(message);
		}

		if (nextLogger != null) {
			nextLogger.logMessage(level, message);
		}
	}

	protected abstract void write(String message);
}

```



创建扩展了该记录器类的实体类

ConsoleLogger.java

```java
package crPattern;

public class ConsoleLogger extends AbstractLogger {

	public ConsoleLogger(int level) {
		this.level = level;
	}

	@Override
	protected void write(String message) {
		System.out.println("Standard Console::Logger: " + message);
	}

}

```

ErrorLogger.java

```java
package crPattern;

public class ErrorLogger extends AbstractLogger {

	public ErrorLogger(int level) {
		this.level = level;
	}

	@Override
	protected void write(String message) {
		System.out.println("Error Console::Logger: " + message);
	}

}

```

FileLogger.java

```java
package crPattern;

public class FileLogger extends AbstractLogger {

	public FileLogger(int level) {
		this.level = level;
	}

	@Override
	protected void write(String message) {
		System.out.println("File::Logger: " + message);
	}

}

```



创建不同类型的记录器，赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。

ChainPatternDemo.java

```java
package crPattern;

public class ChainPatternDemo {

	private static AbstractLogger getChainOfLoggers() {
		AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
		AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);
		AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);

		errorLogger.setNextLogger(fileLogger);
		fileLogger.setNextLogger(consoleLogger);

		return errorLogger;
	}

	public static void main(String[] args) {
		AbstractLogger loggerChain = getChainOfLoggers();

		loggerChain.logMessage(AbstractLogger.INFO, "This is an information.");

		loggerChain.logMessage(AbstractLogger.DEBUG, "This is an debug level information.");

		loggerChain.logMessage(AbstractLogger.ERROR, "This is an error information.");
	}
}

```



## 命令模式

数据驱动的设计模式，行为型模式

### 示例代码

创建一个命令接口

Order.java

```java
package commandPattern;

public interface Order {
	void execute();
}

```



创建一个请求类

Stock.java

```java
package commandPattern;

public class Stock {
	private String name = "ABC";
	private int quantity = 10;

	public void buy() {
		System.out.println("Stock [ Name: " + name + " , Quantity: " + quantity + " ] bought");
	}

	public void sell() {
		System.out.println("Stock [ Name: " + name + " , Quantity: " + quantity + " ] sold");
	}
}

```



创建实现了Order接口的实体类

BuyStock.java

```java
package commandPattern;

public class BuyStock implements Order {
	private Stock abcStock;

	public BuyStock(Stock abcStock) {
		this.abcStock = abcStock;
	}

	@Override
	public void execute() {
		abcStock.buy();
	}

}

```

SellStock.java

```java
package commandPattern;

public class SellStock implements Order {
	private Stock abcStock;

	public SellStock(Stock abcStock) {
		this.abcStock = abcStock;
	}

	@Override
	public void execute() {
		abcStock.sell();
	}

}

```



创建命令调用类

Broker.java

```java
package commandPattern;

import java.util.ArrayList;
import java.util.List;

public class Broker {
	private List<Order> orderList = new ArrayList<Order>();

	public void takeOrder(Order order) {
		orderList.add(order);
	}

	public void placeOrders() {
		for (Order order : orderList) {
			order.execute();
		}
		orderList.clear();
	}
}

```



使用Broker类来接受并执行命令

CommandPatternDemo.java

```java
package commandPattern;

public class CommandPatternDemo {

	public static void main(String[] args) {
		Stock abcStock = new Stock();

		BuyStock buyStockOrder = new BuyStock(abcStock);
		SellStock sellStockOrder = new SellStock(abcStock);

		Broker broker = new Broker();
		broker.takeOrder(buyStockOrder);
		broker.takeOrder(sellStockOrder);

		broker.placeOrders();
	}
}

```



## 解释器模式

行为型模式，用在SQL解析，符号处理引擎

### 应用实例

编译器，运算表达式计算

### 示例代码

创建一个表达式接口

Expression.java

```java
package interpreterPattern;

public interface Expression {
	public boolean interpret(String context);
}

```



创建实现了上述接口的实体类

TerminalExpression.java

```java
package interpreterPattern;

public class TerminalExpression implements Expression {

	private String data;

	public TerminalExpression(String data) {
		this.data = data;
	}

	@Override
	public boolean interpret(String context) {
		if (context.contains(data)) {
			return true;
		}

		return false;
	}

}

```

OrExpression.java

```java
package interpreterPattern;

public class OrExpression implements Expression {

	private Expression expr1;
	private Expression expr2;

	public OrExpression(Expression expr1, Expression expr2) {
		this.expr1 = expr1;
		this.expr2 = expr2;
	}

	@Override
	public boolean interpret(String context) {
		return expr1.interpret(context) || expr2.interpret(context);
	}

}

```

AndExpression.java

```java
package interpreterPattern;

public class AndExpression implements Expression {

	private Expression expr1;
	private Expression expr2;

	public AndExpression(Expression expr1, Expression expr2) {
		this.expr1 = expr1;
		this.expr2 = expr2;
	}

	@Override
	public boolean interpret(String context) {
		return expr1.interpret(context) && expr2.interpret(context);
	}

}

```



InterpreterPatternDemo使用Expression类来创建规则，并解析它们

InterpreterPatternDemo.java

```java
package interpreterPattern;

public class InterpreterPatternDemo {

	public static Expression getMaleExpression() {
		Expression robert = new TerminalExpression("Robert");
		Expression john = new TerminalExpression("John");

		return new OrExpression(robert, john);
	}

	public static Expression getMarriedWomanExpression() {
		Expression julie = new TerminalExpression("Julie");
		Expression married = new TerminalExpression("Married");

		return new AndExpression(julie, married);
	}

	public static void main(String[] args) {
		Expression isMale = getMaleExpression();
		Expression isMarriedWoman = getMarriedWomanExpression();

		System.out.println("John is male? " + isMale.interpret("John"));
		System.out.println("Julie is a married women? " + isMarriedWoman.interpret("Married Julie"));
	}
}

```



## 迭代器模式

行为型模式，用于顺序访问集合对象的元素，不需要知道集合对象的底层表示

### 应用实例

java中的iterator

### 示例代码

创建接口

Iterator.java

```java
package iteratorPattern;

public interface Iterator {

	public boolean hasNext();

	public Object next();
}

```

Container.java

```java
package iteratorPattern;

public interface Container {

	public Iterator getIterator();
}

```



创建实现了Container接口的实体类。该类有实现了Iterator接口的内部类NameIterator

NameRepository.java

```java
package iteratorPattern;

public class NameRepository implements Container {

	public String[] names = { "Robert", "John", "Julie", "Lora" };

	@Override
	public Iterator getIterator() {
		return new NameIterator();
	}

	private class NameIterator implements Iterator {

		int index;

		@Override
		public boolean hasNext() {
			if (index < names.length) {
				return true;
			}

			return false;
		}

		@Override
		public Object next() {
			if (this.hasNext()) {
				return names[index++];
			}

			return null;
		}

	}
}

```



使用NameRepository来获取迭代器，并打印名字

IteratorPatternDemo.java

```java
package iteratorPattern;

public class IteratorPatternDemo {

	public static void main(String[] args) {
		NameRepository nr = new NameRepository();

		for (Iterator it = nr.getIterator(); it.hasNext();) {
			String name = (String) it.next();
			System.out.println("Name : " + name);
		}
	}
}

```



## 中介者模式

行为型模式，降低多个对象和类之间的通信复杂性

### 应用实例

MVC中的C

### 示例代码

创建中介类

ChatRoom.java

```java
package mediatorPattern;

import java.util.Date;

public class ChatRoom {

	public static void showMessage(User user, String message) {
		System.out.println(new Date().toString() + " [ " + user.getName() + " ] : " + message);
	}
}

```



创建User类

User.java

```java
package mediatorPattern;

public class User {

	private String name;
	
	public User(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public void sendMessage(String message) {
		ChatRoom.showMessage(this, message);
	}
}

```



使用User对象来显示它们之间的通信

MediatorPatternDemo.java

```java
package mediatorPattern;

public class MediatorPatternDemo {

	public static void main(String[] args) {
		User robert = new User("Robert");
		User john = new User("John");

		robert.sendMessage("Hi! John!");
		john.sendMessage("Hello! Robert!");
	}
}

```



## 备忘录模式

行为型模式，保存一个对象的状态，在适当的时候可以恢复对象

### 应用实例

后悔药，游戏存档，IE中的后退，数据库的事务管理

### 示例代码

创建Memento类

Memento.java

```java
package mementoPattern;

public class Memento {
	private String state;

	public Memento(String state) {
		this.state = state;
	}

	public String getState() {
		return state;
	}

}

```



创建Originator类

Originator.java

```java
package mementoPattern;

public class Originator {
	private String state;

	public String getState() {
		return state;
	}

	public void setState(String state) {
		this.state = state;
	}

	public Memento saveStateToMemento() {
		return new Memento(state);
	}

	public void getStateFromMemento(Memento memento) {
		state = memento.getState();
	}
}

```



创建CareTaker类

CareTaker.java

```java
package mementoPattern;

import java.util.ArrayList;
import java.util.List;

public class CareTaker {

	private List<Memento> mementoList = new ArrayList<Memento>();

	public void add(Memento state) {
		mementoList.add(state);
	}

	public Memento get(int index) {
		return mementoList.get(index);
	}
}

```



使用CareTaker和Originator对象

MementoPatternDemo.java

```java
package mementoPattern;

public class MementoPatternDemo {

	public static void main(String[] args) {
		Originator originator = new Originator();
		CareTaker ct = new CareTaker();

		originator.setState("State #1");
		originator.setState("State #2");
		ct.add(originator.saveStateToMemento());
		originator.setState("State #3");
		ct.add(originator.saveStateToMemento());
		originator.setState("State #4");

		System.out.println("Current State: " + originator.getState());
		originator.getStateFromMemento(ct.get(0));
		System.out.println("First saved State: " + originator.getState());
		originator.getStateFromMemento(ct.get(1));
		System.out.println("Second saved State: " + originator.getState());
	}
}

```



## 观察者模式

行为型模式，当对象存储一对多关系时，则使用观察者模式

### 示例代码

创建Subject类

Subject.java

```java
package observerPattern;

import java.util.ArrayList;
import java.util.List;

public class Subject {

	private List<Observer> observers = new ArrayList<Observer>();
	private int state;

	public int getState() {
		return state;
	}

	public void setState(int state) {
		this.state = state;
		notifyAllObservers();
	}

	public void attach(Observer observer) {
		observers.add(observer);
	}

	public void notifyAllObservers() {
		for (Observer observer : observers) {
			observer.update();
		}
	}
}

```



创建Observer类

Observer.java

```java
package observerPattern;

public abstract class Observer {
	protected Subject subject;

	public abstract void update();
}

```



创建实体观察者类

BinaryObserver.java

```java
package observerPattern;

public class BinaryObserver extends Observer {

	public BinaryObserver(Subject subject) {
		this.subject = subject;
		this.subject.attach(this);
	}

	@Override
	public void update() {
		System.out.println("Binary String: " + Integer.toBinaryString(subject.getState()));
	}

}

```

OctalObserver.java

```java
package observerPattern;

public class OctalObserver extends Observer {

	public OctalObserver(Subject subject) {
		this.subject = subject;
		this.subject.attach(this);
	}

	@Override
	public void update() {
		System.out.println("Octal String: " + Integer.toOctalString(subject.getState()));
	}

}

```

HexaObserver.java

```java
package observerPattern;

public class HexaObserver extends Observer {

	public HexaObserver(Subject subject) {
		this.subject = subject;
		this.subject.attach(this);
	}

	@Override
	public void update() {
		System.out.println("Hex String: " + Integer.toHexString(subject.getState()).toUpperCase());
	}

}

```



使用Subject和实体观察者对象

ObserverPatternDemo.java

```java
package observerPattern;

public class ObserverPatternDemo {

	public static void main(String[] args) {
		Subject subject = new Subject();

		new HexaObserver(subject);
		new OctalObserver(subject);
		new BinaryObserver(subject);

		System.out.println("First state change: 15");
		subject.setState(15);

		System.out.println("Second state change: 10");
		subject.setState(10);
	}
}

```



## 状态模式

行为型模式，类的行为基于状态改变

### 示例代码

创建一个接口

State.java

```java
package statePattern;

public interface State {
	public void doAction(Context context);
}

```



创建实现接口的实体类

StartState.java

```java
package statePattern;

public class StartState implements State {

	@Override
	public void doAction(Context context) {
		System.out.println("Player is in start state");
		context.setState(this);
	}
	
	@Override
	public String toString() {
		return "Start State";
	}

}

```

StopState.java

```java
package statePattern;

public class StopState implements State {

	@Override
	public void doAction(Context context) {
		System.out.println("Player is in stop state");
		context.setState(this);
	}

	@Override
	public String toString() {
		return "Stop State";
	}
}

```



创建Context类

Context.java

```java
package statePattern;

public class Context {
	private State state;

	public Context() {
	}

	public State getState() {
		return state;
	}

	public void setState(State state) {
		this.state = state;
	}

}

```



使用Context来查看当状态State改变时的行为变化

StatePatternDemo.java

```java
package statePattern;

public class StatePatternDemo {

	public static void main(String[] args) {
		Context context = new Context();

		StartState startState = new StartState();
		startState.doAction(context);

		System.out.println(context.getState().toString());

		StopState stopState = new StopState();
		stopState.doAction(context);

		System.out.println(context.getState().toString());
	}
}

```



## 空对象模式

行为型模式，一个空对象取代NULL对象，是一个不做任何动作的对象

### 示例代码

创建一个抽象类

AbstractCustomer.java

```java
package nullObjectPattern;

public abstract class AbstractCustomer {

	protected String name;

	public abstract boolean isNil();

	public abstract String getName();
}

```



创建扩展了上述类的实体类

RealCustomer.java

```java
package nullObjectPattern;

public class RealCustomer extends AbstractCustomer {

	public RealCustomer(String name) {
		this.name = name;
	}

	@Override
	public boolean isNil() {
		return false;
	}

	@Override
	public String getName() {
		return name;
	}

}

```

NullCustomer.java

```java
package nullObjectPattern;

public class NullCustomer extends AbstractCustomer {

	@Override
	public boolean isNil() {
		return true;
	}

	@Override
	public String getName() {
		return "Not Available in Customer Database";
	}

}

```



创建CustomerFacctory类

CustomerFactory.java

```java
package nullObjectPattern;

public class CustomerFactory {

	public static final String[] names = { "Rob", "Joe", "Julie" };

	public static AbstractCustomer getCustomer(String name) {
		for (int i = 0; i < names.length; i++) {
			if (names[i].equalsIgnoreCase(name)) {
				return new RealCustomer(name);
			}
		}

		return new NullCustomer();
	}
}

```



使用CustomerFactory，基于客户传递的名字，来获取RealCustomer或NullCustomer对象

NullPatternDemo.java

```java
package nullObjectPattern;

public class NullPatternDemo {

	public static void main(String[] args) {
		AbstractCustomer customer1 = CustomerFactory.getCustomer("Rob");
		AbstractCustomer customer2 = CustomerFactory.getCustomer("Bob");
		AbstractCustomer customer3 = CustomerFactory.getCustomer("Julie");
		AbstractCustomer customer4 = CustomerFactory.getCustomer("Laura");

		System.out.println("Customers");
		System.out.println(customer1.getName());
		System.out.println(customer2.getName());
		System.out.println(customer3.getName());
		System.out.println(customer4.getName());
	}
}

```



## 策略模式

行为型模式，一个类的行为或其算法可以在运行时更改

### 示例代码

创建一个接口

Strategy.java

```java
package strategyPattern;

public interface Strategy {
	public int doOperation(int num1, int num2);
}

```



创建实现接口的实体类

OperationAdd.java

```java
package strategyPattern;

public class OperationAdd implements Strategy {

	@Override
	public int doOperation(int num1, int num2) {
		return num1 + num2;
	}

}

```

OperationSubstract.java

```java
package strategyPattern;

public class OperationSubstract implements Strategy {

	@Override
	public int doOperation(int num1, int num2) {
		return num1 - num2;
	}

}

```

OperationMultiply.java

```java
package strategyPattern;

public class OperationMultiply implements Strategy {

	@Override
	public int doOperation(int num1, int num2) {
		return num1 * num2;
	}

}

```



创建Context类

Context.java

```java
package strategyPattern;

public class Context {

	private Strategy strategy;

	public Context(Strategy strategy) {
		this.strategy = strategy;
	}

	public int executeStrategy(int num1, int num2) {
		return strategy.doOperation(num1, num2);
	}
}

```



使用Context来查看当它改变策略Strategy时的行为变化

StrategyPatternDemo.java

```java
package strategyPattern;

public class StrategyPatternDemo {

	public static void main(String[] args) {
		Context context = new Context(new OperationAdd());
		System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

		context = new Context(new OperationSubstract());
		System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

		context = new Context(new OperationMultiply());
		System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
	}
}

```



## 模板模式

行为型模式，抽象类定义方法，它的子类按需要重写方法实现

### 示例代码

创建一个抽象类，它的模板方法被设置为final

Game.java

```java
package templatePattern;

public abstract class Game {
	abstract void initialize();

	abstract void startPlay();

	abstract void endPlay();

	public final void play() {
		initialize();

		startPlay();

		endPlay();
	}
}

```



创建扩展了上述类的实体类

Cricket.java

```java
package templatePattern;

public class Cricket extends Game {

	@Override
	void initialize() {
		System.out.println("Cricket Game Initialized! Start playing.");
	}

	@Override
	void startPlay() {
		System.out.println("Cricket Game Started. Enjoy the game!");
	}

	@Override
	void endPlay() {
		System.out.println("Cricket Game Finished!");
	}

}

```

Foolball.java

```java
package templatePattern;

public class Football extends Game {

	@Override
	void initialize() {
		System.out.println("Football Game Initialized! Start playing.");
	}

	@Override
	void startPlay() {
		System.out.println("Football Game Started. Enjoy the game!");
	}

	@Override
	void endPlay() {
		System.out.println("Football Game Finished!");
	}

}

```



使用Game的模板方法play()来演示游戏的定义方式

TemplatePatternDemo.java

```java
package templatePattern;

public class TemplatePatternDemo {

	public static void main(String[] args) {
		Game game = new Cricket();
		game.play();

		System.out.println();
		game = new Football();
		game.play();
	}
}

```



## 访问者模式

行为型模式，使用一个访问者类，改变元素类的执行算法

### 示例代码

定义一个表示元素的接口

ComputerPart.java

```java
package visitorPattern;

public interface ComputerPart {
	public void accept(ComputerPartVisitor computerPartVisitor);
}

```



创建扩展了上述类的实体类

Keyboard.java

```java
package visitorPattern;

public class Keyboard implements ComputerPart {

	@Override
	public void accept(ComputerPartVisitor computerPartVisitor) {
		computerPartVisitor.visit(this);
	}

}

```

Monitor.java

```java
package visitorPattern;

public class Monitor implements ComputerPart {

	@Override
	public void accept(ComputerPartVisitor computerPartVisitor) {
		computerPartVisitor.visit(this);
	}

}

```

Mouse.java

```java
package visitorPattern;

public class Mouse implements ComputerPart {

	@Override
	public void accept(ComputerPartVisitor computerPartVisitor) {
		computerPartVisitor.visit(this);
	}

}

```

Computer.java

```java
package visitorPattern;

public class Computer implements ComputerPart {

	ComputerPart[] parts;

	public Computer() {
		parts = new ComputerPart[] { new Mouse(), new Keyboard(), new Monitor() };
	}

	@Override
	public void accept(ComputerPartVisitor computerPartVisitor) {

		for (int i = 0; i < parts.length; i++) {
			parts[i].accept(computerPartVisitor);
		}
		computerPartVisitor.visit(this);
	}

}

```



定义一个表示访问者的接口

ComputerPartVisitor.java

```java
package visitorPattern;

public interface ComputerPartVisitor {

	public void visit(Computer computer);

	public void visit(Mouse mouse);

	public void visit(Keyboard keyboard);

	public void visit(Monitor monitor);
}

```



创建实现了上述类的实体访问者

ComputerPartDisplayVisitor.java

```java
package visitorPattern;

public class ComputerPartDisplayVisitor implements ComputerPartVisitor {

	@Override
	public void visit(Computer computer) {
		System.out.println("Displaying Computer");
	}

	@Override
	public void visit(Mouse mouse) {
		System.out.println("Displaying Mouse");
	}

	@Override
	public void visit(Keyboard keyboard) {
		System.out.println("Displaying Keyboard");
	}

	@Override
	public void visit(Monitor monitor) {
		System.out.println("Displaying Monitor");
	}

}

```



使用ComputerPartDisplayVisitor来显示Computer的组成部分

VisitorPatternDemo.java

```java
package visitorPattern;

public class VisitorPatternDemo {

	public static void main(String[] args) {
		ComputerPart computer = new Computer();
		computer.accept(new ComputerPartDisplayVisitor());
	}
}

```

